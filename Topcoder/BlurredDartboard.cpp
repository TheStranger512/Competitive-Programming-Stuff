/* Solved
 * TCO 2012 Round 2A Easy
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

#ifdef AZN
#include "Azn.cpp"
#endif

using namespace std;

struct BlurredDartboard {
  int minThrows(vector <int> points, int P);
} ;

int BlurredDartboard::minThrows(vector <int> points, int P) {
  int N = points.size();
  vector<int> mys;
  int best = *max_element(points.begin(), points.end());
  for (int i = 1; i <= N; i++)
    if (!count(points.begin(), points.end(), i))
      mys.push_back(i);
  //pln(best, mys);
  if (best == 0) {
    //all mystery
    int sum = N * (N + 1) / 2;
    int res = P / sum * N;
    P %= sum;
    for (int i = 1; P > 0; i++) {
      P -= i;
      res++;
    }
    return res;
  }
  if (best == N)
    return (P + N - 1) / N;//know largest element
  int dp[55];
  int res = -1, M = mys.size();
  dp[0] = 0;
  for (int i = 1, sum = 0; i <= M; i++) {
    sum += mys[i - 1];
    dp[i] = max(sum, dp[i - 1] + best);
  }
  //pln(best);
  //plnarr(dp, dp + M + 1);
  for (int low = 1, high = P; low <= high; ) {
    int mid = (low + high) >> 1;
    long long cnt = mid / M * 1LL * dp[M]  + dp[mid % M];
    if (cnt >= P) {
      res = mid;
      high = mid - 1;
    }
    else low = mid + 1;
  }
  return res;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof

bool KawigiEdit_RunTest(int testNum, vector <int> p0, int p1, bool hasAnswer, int p2) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p0[i];
  }
  cout << "}" << "," << p1;
  cout << "]" << endl;
  BlurredDartboard *obj;
  int answer;
  obj = new BlurredDartboard();
  clock_t startTime = clock();
  answer = obj->minThrows(p0, p1);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p2 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p2;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  }
  else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  }
  else if (hasAnswer) {
    cout << "Match :-)" << endl;
  }
  else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}

int main() {
  #ifdef AZN
  freopen("output.txt", "w", stdout);
  freopen("azn.txt", "w", stderr);
  #endif

  bool all_right;
  all_right = true;

  vector <int> p0;
  int p1;
  int p2;

  {
    // ----- test 0 -----
    int t0[] = {0, 3, 4, 0, 0};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 8;
    p2 = 2;
    all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    int t0[] = {0, 0, 0, 0, 0};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 15;
    p2 = 5;
    all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 2 -----
    int t0[] = {4, 7, 8, 1, 3, 2, 6, 5};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 2012;
    p2 = 252;
    all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 3 -----
    int t0[] = {0, 0, 5, 0, 0, 0, 1, 3, 0, 0};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 2012;
    p2 = 307;
    all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 4 -----
    int t0[] = {0, 2, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 6, 0, 0, 0, 4, 0, 0, 0};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 1000000000;
    p2 = 84656087;
    all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 5 -----
    int t0[] = {0, 0, 0, 0, 0};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 23;
    all_right = KawigiEdit_RunTest(5, p0, p1, false, p2) && all_right;
    // ------------------
  }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  }
  else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// This problem statement contains superscripts and/or subscripts. It may not display properly outside the applet.
//
//
// Wojtek and Tomek are playing darts. Unfortunately the dartboard is blurred and Wojtek can't read some of the numbers written on it. On the other hand, Tomek remembers the numbers written on the dartboard.
//
//
// The dartboard is divided into N parts. Wojtek knows that for each integer x between 1 and N, inclusive, there is exactly one part that is worth x points. You are given a vector <int> points containing N integers. If points[i] is positive, the i-th part is worth points[i] points. If points[i] is zero, he can't read the number that indicates the point value of the i-th part.
//
//
// Wojtek and Tomek will play the following game. First, Wojtek throws K darts. Wojtek is perfectly skilled at darts, so he will certainly hit the parts he wants to hit. He is allowed to hit the same part with multiple darts. After Wojtek throws all the darts, Tomek calculates Wojtek's total score. The total score is simply the sum of the points hit by each of the darts. (Note that each part of the dartboard may be counted multiple times if Wojtek hits it with multiple darts.) If the total score is at least P points, Wojtek wins. Otherwise, Tomek wins.
//
//
// You are given the vector <int> points and the int P. Return the smallest K such that Wojtek is guaranteed to win the game if he follows the optimal strategy when throwing the darts.
//
// DEFINITION
// Class:BlurredDartboard
// Method:minThrows
// Parameters:vector <int>, int
// Returns:int
// Method signature:int minThrows(vector <int> points, int P)
//
//
// CONSTRAINTS
// -points will contain between 1 and 50 elements, inclusive.
// -Each element of points will be between 0 and N, inclusive, where N is the number of elements in points.
// -Each of the integers from 1 to N, inclusive, will appear at most once in points.
// -P will be between 1 and 1,000,000,000 (109), inclusive.
//
//
// EXAMPLES
//
// 0)
// {0, 3, 4, 0, 0}
// 8
//
// Returns: 2
//
// Wojtek should hit part 2 twice. He will get 8 points.
//
// 1)
// {0, 0, 0, 0, 0}
// 15
//
// Returns: 5
//
// Wojtek should hit each part exactly once. He doesn't know the point values, but the total score will be always 15.
//
// 2)
// {4, 7, 8, 1, 3, 2, 6, 5}
// 2012
//
// Returns: 252
//
//
//
// 3)
// {0, 0, 5, 0, 0, 0, 1, 3, 0, 0}
// 2012
//
// Returns: 307
//
//
//
// 4)
// {0, 2, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 6, 0, 0, 0, 4, 0, 0, 0}
// 1000000000
//
// Returns: 84656087
//
//
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
