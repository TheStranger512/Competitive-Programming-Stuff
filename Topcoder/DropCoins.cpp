/*
 * Solved
 * SRM 525 Div2 Medium/Div1 Easy
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

using namespace std;

template <class A> inline void pln(A a) {
  cout << a << endl;
}

template <class it> inline void plnarr(it begin, it end) {
  cout << '[';
  if (begin < end) {
    while (true) {
      cout << (*begin);
      if (++begin == end)break;
      else cout << ',';
    }
  }
  cout << ']' << endl;
}
typedef long long llong;

class DropCoins {
public:
  int getMinimum(vector <string> board, int K);
} ;

int cnt[33][33];
int rows, cols;

int getcnt(int r1, int c1, int r2, int c2) {
  return cnt[r2][c2] - cnt[r1 - 1][c2] - cnt[r2][c1 - 1] + cnt[r1 - 1][c1 - 1];
}

int getsteps(int len, int st, int ed) {
  int a = len - ed, b = st - 1;
  if (a > b) swap(a, b);
  return 2 * a + b;
}

int DropCoins::getMinimum(vector <string> board, int K) {
  memset(cnt, 0, sizeof (cnt));
  rows = board.size();
  cols = board[0].size();
  for (int r = 0; r < rows; r++) {
    for (int c = 0; c < cols; c++) {
      if (board[r][c] == 'o') cnt[r + 1][c + 1]++;
      cnt[r + 1][c + 1] += cnt[r][c + 1] + cnt[r + 1][c] - cnt[r][c];
    }
  }
  int ans = 1 << 20;
  for (int r1 = 1; r1 <= rows; r1++) {
    for (int c1 = 1; c1 <= cols; c1++) {
      for (int r2 = r1; r2 <= rows; r2++) {
        for (int c2 = c1; c2 <= cols; c2++) {
          if (getcnt(r1, c1, r2, c2) != K) continue;
          ans = min(ans, getsteps(rows, r1, r2) + getsteps(cols, c1, c2));
        }
      }
    }
  }
  if (ans >= (1 << 20)) return -1;
  else return ans;
}




// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;

bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, bool hasAnswer, int p2) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << "\"" << p0[i] << "\"";
  }
  cout << "}" << "," << p1;
  cout << "]" << endl;
  DropCoins *obj;
  int answer;
  obj = new DropCoins();
  clock_t startTime = clock();
  answer = obj->getMinimum(p0, p1);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p2 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p2;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  }
  else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  }
  else if (hasAnswer) {
    cout << "Match :-)" << endl;
  }
  else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}

int main() {
  bool all_right;
  all_right = true;

  vector <string> p0;
  int p1;
  int p2;

  {
    // ----- test 0 -----
    string t0[] = {".o..", "oooo", "..o."};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 3;
    p2 = 2;
    all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    string t0[] = {".....o", "......", "oooooo", "oooooo", "......", "o....."};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 12;
    p2 = 3;
    all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 2 -----
    string t0[] = {"....", ".oo.", ".oo.", "...."};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 3;
    p2 = -1;
    all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 3 -----
    string t0[] = {".......", "..ooo..", "ooooooo", ".oo.oo.", "oo...oo"};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 12;
    p2 = 4;
    all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 4 -----
    string t0[] = {".................", ".ooooooo...oooo..", ".ooooooo..oooooo.", ".oo.......oo..oo.", ".oo.......oo..oo.", ".ooooo.....oooo..", ".ooooooo...oooo..", ".....ooo..oo..oo.", "......oo..oo..oo.", ".ooooooo..oooooo.", ".oooooo....oooo..", "................."};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 58;
    p2 = 6;
    all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
    // ------------------
  }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  }
  else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// There is a rectangle divided into 1x1 cells. Each cell is either empty or it contains a single coin.
//
// You can apply the following operation repeatedly.
//
// First, choose one of the directions: up, down, left, or right.
// Then, move all coins in the chosen direction by exactly 1 cell. If this would cause a coin to move out of the rectangle, the coin drops out from the rectangle and disappears.
//
// Your objective in this problem is to apply the operations so that the number of coins remaining on the rectangle becomes exactly K.
//
// You are given the int K and a vector <string> board that describes the initial state of the rectangle. More precisely, character j of element i of board is 'o' if i-th row of j-th column of the rectangle contains a coin, and it is '.' otherwise.
//
// Return the minimum number of operations you have to perform. If the objective is impossible, return -1.
//
// DEFINITION
// Class:DropCoins
// Method:getMinimum
// Parameters:vector <string>, int
// Returns:int
// Method signature:int getMinimum(vector <string> board, int K)
//
//
// CONSTRAINTS
// -board will contain between 1 and 30 elements, inclusive.
// -Each element of board will contain between 1 and 30 characters, inclusive.
// -All elements of board will contain the same number of characters.
// -Each character in each element of board will be either '.' or 'o'.
// -K will be between 1 and 900, inclusive.
//
//
// EXAMPLES
//
// 0)
// {".o.."
// ,"oooo"
// ,"..o."}
//
// 3
//
// Returns: 2
//
// One of the optimal solutions is to move coins to the right twice.
//
// 1)
// {".....o"
// ,"......"
// ,"oooooo"
// ,"oooooo"
// ,"......"
// ,"o....."}
//
// 12
//
// Returns: 3
//
// One of the optimal solutions:
//
// move coins up (1 coin drops, 13 remain)
// move coins down
// move coins down again (1 coin drops, 12 remain)
//
//
// 2)
// {"...."
// ,".oo."
// ,".oo."
// ,"...."}
//
// 3
//
// Returns: -1
//
// It is impossible to make the number of remaining coins exactly 3.
//
// 3)
// {"......."
// ,"..ooo.."
// ,"ooooooo"
// ,".oo.oo."
// ,"oo...oo"}
//
// 12
//
// Returns: 4
//
//
//
// 4)
// {"................."
// ,".ooooooo...oooo.."
// ,".ooooooo..oooooo."
// ,".oo.......oo..oo."
// ,".oo.......oo..oo."
// ,".ooooo.....oooo.."
// ,".ooooooo...oooo.."
// ,".....ooo..oo..oo."
// ,"......oo..oo..oo."
// ,".ooooooo..oooooo."
// ,".oooooo....oooo.."
// ,"................."}
//
// 58
//
// Returns: 6
//
//
//
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
