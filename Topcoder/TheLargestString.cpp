/* Solved
 * SRM TCO 13 Round 2A Easy
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

#ifdef AZN
#include "Azn.cpp"
#endif

using namespace std;

struct TheLargestString {
  string find(string s, string t);
} ;

string TheLargestString::find(string s, string t) {
  string ans = "";
  int len = s.size();
  string a = "", b = "";
  for (int i = 0; i < len; ) {
    int best = i, at = i;
    string aa = a, bb = b;
    if ((a + b) > ans)
      ans = a + b;
    while (at < len) {
      int pos = max_element(s.begin() + at, s.end()) - s.begin();
      aa += s[pos];
      bb += t[pos];
      if ((aa + bb) > ans)
        ans = aa + bb;
      at = pos + 1;
    }
    for (int j = i; j < len; j++)
      if ((a + s[j]) + (b + t[j]) > (a + s[best]) + (b + t[best]))
        best = j;
    a += s[best];
    b += t[best];
    i = best + 1;
    if (a + b > ans) ans = a + b;
  }
  return ans;
}


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, string p0, string p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "\"" << p1 << "\"";
	cout << "]" << endl;
	TheLargestString *obj;
	string answer;
	obj = new TheLargestString();
	clock_t startTime = clock();
	answer = obj->find(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
#ifdef AZN
freopen("output.txt", "w", stdout);
freopen("azn.txt", "w", stderr);
#endif

	bool all_right;
	all_right = true;

	string p0;
	string p1;
	string p2;

	{
	// ----- test 0 -----
	p0 = "ab";
	p1 = "zy";
	p2 = "by";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	p0 = "abacaba";
	p1 = "zzzaaaa";
	p2 = "cbaaaa";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	p0 = "x";
	p1 = "x";
	p2 = "xx";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	p0 = "abbabbabbababaaaabbababab";
	p1 = "bababbaabbbababbbbababaab";
	p2 = "bbbbbbbbbbbbbbbbbbaaab";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	p0 = "zzzzz";
	p1 = "aaaaa";
	all_right = KawigiEdit_RunTest(4, p0, p1, false, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 5 -----
	p0 = "bb";
	p1 = "zb";
	all_right = KawigiEdit_RunTest(5, p0, p1, false, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 6 -----
	p0 = "abcdefghijklmnopqrstuvxyzabcdefghijklmnopqrstuvxyz";
	p1 = "abcdefghijklmnopqrstuvxyzabcdefghijklmnopqrstuvxyz";
	all_right = KawigiEdit_RunTest(6, p0, p1, false, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 7 -----
	p0 = "zzzzzzzzzzbbzzzzzzzzzzbbzzzzzzzzzzbbzzzzzzzzzzbb";
	p1 = "hsrthefwjtyktuqfrkuafhjtyyuoqvhkyuzzeyiyiqewgfdh";
	all_right = KawigiEdit_RunTest(7, p0, p1, false, p2) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// John has two strings s and t of equal length.
// He can choose a set of positions (possibly empty) and erase characters at these positions in both s and t.
// Then he writes down the concatenation of what remained of the strings: first the letters we kept from s, in their original order, then the letters we kept from t, again in their original order.
//
//
// Return the lexicographically largest string John can get at the end.
//
//
// DEFINITION
// Class:TheLargestString
// Method:find
// Parameters:string, string
// Returns:string
// Method signature:string find(string s, string t)
//
//
// NOTES
// -String A is lexicographically smaller than string B if either A is a proper prefix of B, or if there is an integer i such that the first i characters of A match the first i characters of B, and character i+1 of A is smaller than character i+1 of B.
//
//
// CONSTRAINTS
// -s will contain between 1 and 47 characters, inclusive.
// -s and t will contain the same number of characters.
// -s will contain only lowercase English characters ('a'-'z').
// -t will contain only lowercase English characters ('a'-'z').
//
//
// EXAMPLES
//
// 0)
// "ab"
// "zy"
//
// Returns: "by"
//
// There are four options here:
//
// Do not erase anything. The resulting string would be "abzy".
// Erase both first characters. The resulting string would be "by".
// Erase both last characters. The resulting string would be "az".
// Erase all characters. The resulting string would be empty.
//
// Among all possible results "by" is the lexicographically largest one.
//
//
// 1)
// "abacaba"
// "zzzaaaa"
//
// Returns: "cbaaaa"
//
//
//
// 2)
// "x"
// "x"
//
// Returns: "xx"
//
//
//
// 3)
// "abbabbabbababaaaabbababab"
// "bababbaabbbababbbbababaab"
//
// Returns: "bbbbbbbbbbbbbbbbbbaaab"
//
//
//
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
