/* Solved
 * SRM 589 Div1 Medium
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

using namespace std;

struct GearsDiv1 {
  int getmin(string color, vector<string> graph);
};

bool g[55][55];
bool vis[55];
int ml[55], col[55];
int N;

bool rec(int at) {
  if (at < 0)
    return true;
  for (int to = 0; to < N; to++) {
    if (!vis[to] && g[at][to]) {
      vis[to] = true;
      if (rec(ml[to])) {
        ml[to] = at;
        return true;
      }
    }
  }
  return false;
}

int GearsDiv1::getmin(string color, vector<string> graph) {
  N = color.size();
  int res = N;
  for (int i = 0; i < N; i++)
    col[i] = color[i] == 'R' ? 0 : color[i] == 'G' ? 1 : 2;
  for (int a = 0; a < 3; a++) {
    for (int b = a + 1; b < 3; b++) {
      memset(g, false, sizeof(g));
      for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
          if (col[i] == a && col[j] == b && graph[i][j] == 'Y')
            g[i][j] = true;
      memset(ml, -1, sizeof(ml));
      int cnt = 0;
      for (int i = 0; i < N; i++) {
        if (col[i] == a) {
          memset(vis, false, sizeof(vis));
          if (rec(i))
            cnt++;
        }
      }
      res = min(res, cnt);
    }
  }
  return res;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, string p0, vector <string> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	GearsDiv1 *obj;
	int answer;
	obj = new GearsDiv1();
	clock_t startTime = clock();
	answer = obj->getmin(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
#ifdef AZN
freopen("output.txt", "w", stdout);
freopen("azn.txt", "w", stderr);
#endif

	bool all_right;
	all_right = true;
	
	string p0;
	vector <string> p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = "RGB";
	string t1[] = {"NYY","YNY","YYN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "RGBR";
	string t1[] = {"NNNN","NNNN","NNNN","NNNN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "RGBR";
	string t1[] = {"NYNN","YNYN","NYNY","NNYN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "RRRRRGRRBGRRGBBGGGBRRRGBRGRRGG";
	string t1[] = {"NNNNNYNNNYNNYNNNYNNNNNNNNYNNYY","NNNNNNNNYNNNYNYNNYNNNNYNNYNNYY","NNNNNYNNNNNNNNNNNNYNNNNNNYNNNY","NNNNNNNNNYNNYNNYYYNNNNYNNYNNNN","NNNNNNNNNYNNYNNYYYNNNNYNNNNNNN","YNYNNNYYYNNYNYYNNNNNYYNYNNYYNN","NNNNNYNNNNNNNNNYYYNNNNYNNYNNYY","NNNNNYNNNNNNNNNYNNNNNNNNNNNNYN","NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY","YNNYYNNNYNNNNYYNNNYNYYNYNNNNNN","NNNNNNNNNNNNYNNYNYNNNNYNNNNNNY","NNNNNYNNNNNNYNNYYYNNNNNNNNNNYN","YYNYYNNNYNYYNYYNNNYNYNNYNNNNNN","NNNNNYNNNYNNYNNYYYNNNNYNNYNYYY","NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY","NNNYYNYYYNYYNYYNNNYNYNNYYNYYNN","YNNYYNYNYNNYNYYNNNYNNNNYYNNYNN","NYNYYNYNYNYYNYYNNNNYYNNYYNYNNN","NNYNNNNNNYNNYNNYYNNNNNYNNYNNNY","NNNNNNNNNNNNNNNNNYNNNNYNNYNNNY","NNNNNYNNNYNNYNNYNYNNNNYNNNNNYY","NNNNNYNNNYNNNNNNNNNNNNYNNNNNNN","NYNYYNYNYNYNNYYNNNYYYYNYYNYNNN","NNNNNYNNNYNNYNNYYYNNNNYNNNNNNY","NNNNNNNNNNNNNNNYYYNNNNYNNYNNYY","YYYYNNYNYNNNNYYNNNYYNNNNYNYYNN","NNNNNYNNNNNNNNNYNYNNNNYNNYNNYN","NNNNNYNNNNNNNYNYYNNNNNNNNYNNYY","YYNNNNYYYNNYNYYNNNNNYNNNYNYYNN","YYYNNNYNYNYNNYYNNNYYYNNYYNNYNN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "RGBRG";
	string t1[] = {"NYYNN","YNYYY","YYNNN","NYNNY","NYNYN"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Goose Tattarrattat has a machine that contains N gears (cogwheels).
// The gears are numbered 0 through N-1.
// Each of the gears has one of three colors: red, green, or blue.
// 
// Some pairs of gears mesh.
// Let X and Y be two meshing gears.
// Note that if X is turning, Y must clearly be turning in the opposite direction (clockwise vs. counter-clockwise).
// Two gears with the same color never mesh.
// Apart from that, do not assume anything about the pairs of meshing gears.
// 
// You are given a string color and a vector <string> graph.
// For each i, character i of color represents the color of gear i: 'R' is red, 'G' is green, and 'B' is blue.
// The vector <string> graph contains the information on meshing pairs of gears:
// If the j-th character of the i-th element of graph is 'Y', gear i meshes with gear j.
// 
// We want all gears to turn at the same time.
// Additionally, all gears of the same color must turn in the same direction.
// Return the minimal number of gears that have to be removed from the machine in order to achieve this goal.
// 
// DEFINITION
// Class:GearsDiv1
// Method:getmin
// Parameters:string, vector <string>
// Returns:int
// Method signature:int getmin(string color, vector <string> graph)
// 
// 
// NOTES
// -Removing a gear creates a gap between the other gears, no new meshing pairs of gears are created by removing a gear.
// -The graph described by graph is not necessarily planar.
// 
// 
// CONSTRAINTS
// -color will contain between 2 and 50 characters, inclusive.
// -Each character in color will be 'R' or 'G' or 'B'.
// -graph will contain exactly N elements, where N is the number of characters in color.
// -Each element of graph will contain exactly N characters, where N is the number of characters in color.
// -Each character in graph will be either 'Y' or 'N'.
// -For each i, the i-th character of the i-th element of graph will be 'N'.
// -For each i and j, the i-th character of the j-th element of graph and the j-th character of the i-th element of graph will be same.
// -For each i and j, if the i-th and the j-th character of color are equal, then the i-th character of the j-th element of graph will be 'N'.
// 
// 
// EXAMPLES
// 
// 0)
// "RGB"
// {"NYY","YNY","YYN"}
// 
// Returns: 1
// 
// We have three gears, each meshes with each of the others.
// In this configuration the gears are not able to turn at all.
// However, as soon as we remove any of the gears, the other two will be able to turn.
// 
// 1)
// "RGBR"
// {"NNNN","NNNN","NNNN","NNNN"}
// 
// Returns: 0
// 
// Here, each of the gears can turn without interacting with the others.
// 
// 2)
// "RGBR"
// {"NYNN","YNYN","NYNY","NNYN"}
// 
// Returns: 1
// 
// These are four gears arranged into a row. It is possible to turn all these gears at the same time, but the two red gears would turn in opposite directions. Thus we need to remove at least one gear.
// 
// 3)
// "RRRRRGRRBGRRGBBGGGBRRRGBRGRRGG"
// {"NNNNNYNNNYNNYNNNYNNNNNNNNYNNYY",
//  "NNNNNNNNYNNNYNYNNYNNNNYNNYNNYY",
//  "NNNNNYNNNNNNNNNNNNYNNNNNNYNNNY",
//  "NNNNNNNNNYNNYNNYYYNNNNYNNYNNNN",
//  "NNNNNNNNNYNNYNNYYYNNNNYNNNNNNN",
//  "YNYNNNYYYNNYNYYNNNNNYYNYNNYYNN",
//  "NNNNNYNNNNNNNNNYYYNNNNYNNYNNYY",
//  "NNNNNYNNNNNNNNNYNNNNNNNNNNNNYN",
//  "NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY",
//  "YNNYYNNNYNNNNYYNNNYNYYNYNNNNNN",
//  "NNNNNNNNNNNNYNNYNYNNNNYNNNNNNY",
//  "NNNNNYNNNNNNYNNYYYNNNNNNNNNNYN",
//  "YYNYYNNNYNYYNYYNNNYNYNNYNNNNNN",
//  "NNNNNYNNNYNNYNNYYYNNNNYNNYNYYY",
//  "NYNNNYNNNYNNYNNYYYNNNNYNNYNNYY",
//  "NNNYYNYYYNYYNYYNNNYNYNNYYNYYNN",
//  "YNNYYNYNYNNYNYYNNNYNNNNYYNNYNN",
//  "NYNYYNYNYNYYNYYNNNNYYNNYYNYNNN",
//  "NNYNNNNNNYNNYNNYYNNNNNYNNYNNNY",
//  "NNNNNNNNNNNNNNNNNYNNNNYNNYNNNY",
//  "NNNNNYNNNYNNYNNYNYNNNNYNNNNNYY",
//  "NNNNNYNNNYNNNNNNNNNNNNYNNNNNNN",
//  "NYNYYNYNYNYNNYYNNNYYYYNYYNYNNN",
//  "NNNNNYNNNYNNYNNYYYNNNNYNNNNNNY",
//  "NNNNNNNNNNNNNNNYYYNNNNYNNYNNYY",
//  "YYYYNNYNYNNNNYYNNNYYNNNNYNYYNN",
//  "NNNNNYNNNNNNNNNYNYNNNNYNNYNNYN",
//  "NNNNNYNNNNNNNYNYYNNNNNNNNYNNYY",
//  "YYNNNNYYYNNYNYYNNNNNYNNNYNYYNN",
//  "YYYNNNYNYNYNNYYNNNYYYNNYYNNYNN"}
// 
// Returns: 3
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
