/* Solved
 * SRM 579 Div2 Easy
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

#ifdef AZN
#include "Azn.cpp"
#endif

using namespace std;

struct PrimalUnlicensedCreatures {
	int maxWins(int initialLevel, vector <int> grezPower);
};

int PrimalUnlicensedCreatures::maxWins(int init, vector <int> power) {
	sort(power.begin(), power.end());
	int res = 0;
	for (int i = 0; i < power.size(); i++)
		if (init > power[i]) {
			res++;
			init += power[i] / 2;
		}
	return res;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	PrimalUnlicensedCreatures *obj;
	int answer;
	obj = new PrimalUnlicensedCreatures();
	clock_t startTime = clock();
	answer = obj->maxWins(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
#ifdef AZN
freopen("output.txt", "w", stdout);
freopen("azn.txt", "w", stderr);
#endif

	bool all_right;
	all_right = true;

	int p0;
	vector <int> p1;
	int p2;

	{
	// ----- test 0 -----
	p0 = 31;
	int t1[] = {10,20,30};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	p0 = 20;
	int t1[] = {24,5,6,38};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	p0 = 20;
	int t1[] = {3,3,3,3,3,1,25};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 6;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	p0 = 4;
	int t1[] = {3,13,6,4,9};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 5;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	p0 = 7;
	int t1[] = {7,8,9,10};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// The Primal Grez are ferocious creatures. They constantly fight each other. When a Grez wins a battle against another Grez, the winner captures the loser's essence, thus becoming stronger. More formally:
// The power level of each Grez is a positive integer.
// A Grez can only defeat creatures that have a strictly smaller power level.
// When a Grez of power level X defeats a Grez of power level Y, the first Grez's power level is increased to X + Y/2. Note that Y/2 represents integer division, i.e., the fractional part is discarded. For example, for Y=3 we have Y/2 = 1.
//
// Your goal is to help a Grez that currently has power level equal to int initialLevel battle against a set of other Grez. For each i, Grez number i (0-based index) has a power level equal to grezPower[i]. Your Grez can challenge the other creatures in any order.
//
// You are given the int initialLevel and the vector <int> grezPower. Return the maximum number of creatures your Grez can defeat, one after another.
//
//
// DEFINITION
// Class:PrimalUnlicensedCreatures
// Method:maxWins
// Parameters:int, vector <int>
// Returns:int
// Method signature:int maxWins(int initialLevel, vector <int> grezPower)
//
//
// CONSTRAINTS
// -initialLevel will be between 1 and 1000, inclusive.
// -grezPower will contain between 1 and 50 elements, inclusive.
// -Each element of grezPower will be between 1 and 1000, inclusive.
//
//
// EXAMPLES
//
// 0)
// 31
// {10, 20, 30}
//
// Returns: 3
//
// It is possible to defeat all the available opponents. For example:
// Defeat the creature with power level 30. Your creature's power level becomes 31 + 15 = 46.
// Defeat the creature with power level 10. Your creature's power level becomes 46 + 5 = 51.
// Defeat the creature with power level 20. Your creature's power level becomes 51 + 10 = 61.
//
//
//
//
// 1)
// 20
// {24, 5, 6, 38}
//
// Returns: 3
//
// It is best to defeat creatures 1 and 2 before facing creature 0. Your creature's power level will be 25 when facing
// creature 0. It is not possible to defeat creature 3.
//
// 2)
// 20
// {3, 3, 3, 3, 3, 1, 25 }
//
// Returns: 6
//
// It is possible to defeat the 6 weakest creatures. After that your creature's power level will be 25, which is not strong enough to defeat another level 25 creature.
//
// 3)
// 4
// {3, 13, 6, 4, 9}
//
// Returns: 5
//
//
//
// 4)
// 7
// {7, 8, 9, 10}
//
// Returns: 0
//
// All the available opponents are too strong for your creature to defeat.
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
