/* Solved
 * SRM 577 Div2 Hard
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

#ifdef AZN
#include "Azn.cpp"
#endif

using namespace std;

struct EllysCoprimesDiv2 {
  int getCount(vector <int> numbers);
} ;

int gcd(int a, int b) {
  while (b != 0) {
    int t = a % b;
    a = b;
    b = t;
  }
  return a;
}

bool can(int a, int b) {
  for (int i = a + 1; i < b; i++)
    if (gcd(a, i) == 1 && gcd(i, b) == 1)
      return true;
  return false;
 }

int EllysCoprimesDiv2::getCount(vector <int> nums) {
  //if (a < b) and gcd(a, b) != 1 then there always exist one or two intergers
  //i, j; a < i, j < b such that needed condition is fulfilled
  sort(nums.begin(), nums.end());
  int len = nums.size(), res = 0;
  for (int i = 1; i < len; i++)
    if (gcd(nums[i], nums[i - 1]) != 1) {
      res++;
      if (!can(nums[i - 1], nums[i])) res++;
    }
  return res;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof

bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p0[i];
  }
  cout << "}";
  cout << "]" << endl;
  EllysCoprimesDiv2 *obj;
  int answer;
  obj = new EllysCoprimesDiv2();
  clock_t startTime = clock();
  answer = obj->getCount(p0);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p1 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p1;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  }
  else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  }
  else if (hasAnswer) {
    cout << "Match :-)" << endl;
  }
  else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}

int main() {
  #ifdef AZN
  freopen("output.txt", "w", stdout);
  freopen("azn.txt", "w", stderr);
  #endif

  bool all_right;
  all_right = true;

  vector <int> p0;
  int p1;

  {
    // ----- test 0 -----
    int t0[] = {2200, 42, 2184, 17};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 3;
    all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    int t0[] = {13, 1, 6, 20, 33};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 0;
    all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
    // ------------------
  }

  {
    // ----- test 2 -----
    int t0[] = {7, 42};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 1;
    all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
    // ------------------
  }

  {
    // ----- test 3 -----
    int t0[] = {55780, 44918, 55653, 4762, 41536, 40083, 79260, 7374, 24124, 91858, 7856, 12999, 64025, 12706, 19770, 71495, 32817, 79309, 53779, 8421, 97984, 34586, 893, 64549, 77792, 12143, 52732, 94416, 54207, 51811, 80845, 67079, 14829, 25350, 22976, 23932, 62273, 58871, 82358, 13283, 33667, 64263, 1337, 42666};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    p1 = 15;
    all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
    // ------------------
  }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  }
  else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// Elly has a set of unique positive integers, given in the vector <int> numbers. She wants to add several (possibly none) new positive integers to this set, such that when the set is sorted no two consecutive numbers will share a positive divisor greater than 1. Return the smallest possible count of new numbers, with which she can achieve that.
//
// DEFINITION
// Class:EllysCoprimesDiv2
// Method:getCount
// Parameters:vector <int>
// Returns:int
// Method signature:int getCount(vector <int> numbers)
//
//
// CONSTRAINTS
// -numbers will contain between 1 and 50 elements, inclusive.
// -Each element of numbers will be between 1 and 100,000, inclusive.
// -All elements of numbers will be distinct.
//
//
// EXAMPLES
//
// 0)
// {2200, 42, 2184, 17}
//
// Returns: 3
//
// Here one possible set of additional numbers is {43, 2195, 2199}.
// The sorted sequence is (17, 42, 43, 2184, 2195, 2199, 2200), and as you may see, no two consecutive numbers share a divisor greater than one.
//
// 1)
// {13, 1, 6, 20, 33}
//
// Returns: 0
//
// For some sets, such as this one, no additional numbers are needed. When sorted, no pair of consecutive numbers shares a common divisor greater than 1.
//
// 2)
// {7, 42}
//
// Returns: 1
//
// Note that prime numbers are not coprime with all other numbers.
//
// 3)
// {55780, 44918, 55653, 4762, 41536, 40083, 79260, 7374, 24124, 91858, 7856,
//  12999, 64025, 12706, 19770, 71495, 32817, 79309, 53779, 8421, 97984, 34586,
//  893, 64549, 77792, 12143, 52732, 94416, 54207, 51811, 80845, 67079, 14829,
//  25350, 22976, 23932, 62273, 58871, 82358, 13283, 33667, 64263, 1337, 42666}
//
// Returns: 15
//
// Large random set of numbers.
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
