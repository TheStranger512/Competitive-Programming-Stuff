/*
 * Solved
 * SRM 492 Div2 Easy
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

#ifdef AZN
#include "Azn.cpp"
#endif

using namespace std;

class TimeTravellingCellar {
public:
  int determineProfit(vector <int> profit, vector <int> decay);
} ;

int TimeTravellingCellar::determineProfit(vector <int> profit, vector <int> decay) {
  int ans = 0, len = profit.size();
  for (int i = 0; i < len; i++)
    for (int j = 0; j < len; j++)
      if (i != j)
        ans = max(ans, profit[i] - decay[j]);
  return ans;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof

bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p0[i];
  }
  cout << "}" << "," << "{";
  for (int i = 0; int(p1.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p1[i];
  }
  cout << "}";
  cout << "]" << endl;
  TimeTravellingCellar *obj;
  int answer;
  obj = new TimeTravellingCellar();
  clock_t startTime = clock();
  answer = obj->determineProfit(p0, p1);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p2 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p2;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  }
  else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  }
  else if (hasAnswer) {
    cout << "Match :-)" << endl;
  }
  else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}

int main() {
  #ifdef AZN
  freopen("output.txt", "w", stdout);
  freopen("azn.txt", "w", stderr);
  #endif

  bool all_right;
  all_right = true;

  vector <int> p0;
  vector <int> p1;
  int p2;

  {
    // ----- test 0 -----
    int t0[] = {1, 2, 3};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {3, 1, 2};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    p2 = 2;
    all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    int t0[] = {3, 2};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {1, 2};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    p2 = 1;
    all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 2 -----
    int t0[] = {3, 3, 3};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {1, 1, 1};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    p2 = 2;
    all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
    // ------------------
  }

  {
    // ----- test 3 -----
    int t0[] = {1000, 500, 250, 125};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {64, 32, 16, 8};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    p2 = 992;
    all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
    // ------------------
  }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  }
  else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// Gogo owns N wine cellars, numbered 0 through N-1. He possesses a time machine and will use it to advance time in one of the cellars, maturing all the wine inside. However, as a side effect, he must also choose one other cellar and turn back time there, making the wine inside younger.
//
//
// You are given two vector <int>s, profit and decay. Advancing time in cellar i will gain Gogo a profit of profit[i]. Turning back time in cellar i will lose him decay[i] in profit. Return the maximum profit that Gogo can gain by advancing time in one cellar and turning time back in another cellar. It is guaranteed that this profit will be positive.
//
// DEFINITION
// Class:TimeTravellingCellar
// Method:determineProfit
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int determineProfit(vector <int> profit, vector <int> decay)
//
//
// CONSTRAINTS
// -profit will contain between 2 and 50 elements, inclusive.
// -Each element of profit will be between 1 and 10000, inclusive.
// -decay will contain the same number of elements as profit.
// -Each element of decay will be between 1 and 10000, inclusive.
// -The maximum profit that Gogo can gain will be positive.
//
//
// EXAMPLES
//
// 0)
// {1,2,3}
// {3,1,2}
//
// Returns: 2
//
// Advance time in cellar 2 and turn back time in cellar 1. The total profit is 3 - 1 = 2.
//
// 1)
// {3,2}
// {1,2}
//
// Returns: 1
//
// He can't advance and turn back time in the same cellar.
//
// 2)
// {3,3,3}
// {1,1,1}
//
// Returns: 2
//
//
//
// 3)
// {1000,500,250,125}
// {64,32,16,8}
//
// Returns: 992
//
//
//
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
