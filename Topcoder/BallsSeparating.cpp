/* Solved
 * SRM 568 Div1 Easy
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

#ifdef AZN
#include "Azn.cpp"
#endif

using namespace std;

class BallsSeparating {
public:
  int minOperations(vector <int> red, vector <int> green, vector <int> blue);
} ;

int BallsSeparating::minOperations(vector <int> red, vector <int> green, vector <int> blue) {
  int ans = 1 << 29, len = red.size();
  if (len < 3) return -1;
  int sum[55];
  for (int i = 0; i < len; i++)
    sum[i] = red[i] + green[i] + blue[i];
  for (int r = 0; r < len; r++) {
    for (int g = 0; g < len; g++) {
      if (r == g) continue;
      for (int b = 0; b < len; b++) {
        if (b == g || b == r) continue;
        int temp = sum[r] - red[r] + sum[g] - green[g] + sum[b] - blue[b];
        for (int k = 0; k < len; k++) {
          if (k == r || k == g || k == b) continue;
          temp += sum[k] - max(red[k], max(green[k], blue[k]));
        }
        ans = min(ans, temp);
      }
    }
  }
  return ans;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof

bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, vector <int> p2, bool hasAnswer, int p3) {
  cout << "Test " << testNum << ": [" << "{";
  for (int i = 0; int(p0.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p0[i];
  }
  cout << "}" << "," << "{";
  for (int i = 0; int(p1.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p1[i];
  }
  cout << "}" << "," << "{";
  for (int i = 0; int(p2.size()) > i; ++i) {
    if (i > 0) {
      cout << ",";
    }
    cout << p2[i];
  }
  cout << "}";
  cout << "]" << endl;
  BallsSeparating *obj;
  int answer;
  obj = new BallsSeparating();
  clock_t startTime = clock();
  answer = obj->minOperations(p0, p1, p2);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p3 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p3;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  }
  else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  }
  else if (hasAnswer) {
    cout << "Match :-)" << endl;
  }
  else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}

int main() {
  #ifdef AZN
  freopen("output.txt", "w", stdout);
  freopen("azn.txt", "w", stderr);
  #endif

  bool all_right;
  all_right = true;

  vector <int> p0;
  vector <int> p1;
  vector <int> p2;
  int p3;

  {
    // ----- test 0 -----
    int t0[] = {1, 1, 1};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {1, 1, 1};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    int t2[] = {1, 1, 1};
    p2.assign(t2, t2 + sizeof (t2) / sizeof (t2[0]));
    p3 = 6;
    all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
    // ------------------
  }

  {
    // ----- test 1 -----
    int t0[] = {5};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {6};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    int t2[] = {8};
    p2.assign(t2, t2 + sizeof (t2) / sizeof (t2[0]));
    p3 = -1;
    all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
    // ------------------
  }

  {
    // ----- test 2 -----
    int t0[] = {4, 6, 5, 7};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {7, 4, 6, 3};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    int t2[] = {6, 5, 3, 8};
    p2.assign(t2, t2 + sizeof (t2) / sizeof (t2[0]));
    p3 = 37;
    all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
    // ------------------
  }

  {
    // ----- test 3 -----
    int t0[] = {7, 12, 9, 9, 7};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {7, 10, 8, 8, 9};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    int t2[] = {8, 9, 5, 6, 13};
    p2.assign(t2, t2 + sizeof (t2) / sizeof (t2[0]));
    p3 = 77;
    all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
    // ------------------
  }

  {
    // ----- test 4 -----
    int t0[] = {842398, 491273, 958925, 849859, 771363, 67803, 184892, 391907, 256150, 75799};
    p0.assign(t0, t0 + sizeof (t0) / sizeof (t0[0]));
    int t1[] = {268944, 342402, 894352, 228640, 903885, 908656, 414271, 292588, 852057, 889141};
    p1.assign(t1, t1 + sizeof (t1) / sizeof (t1[0]));
    int t2[] = {662939, 340220, 600081, 390298, 376707, 372199, 435097, 40266, 145590, 505103};
    p2.assign(t2, t2 + sizeof (t2) / sizeof (t2[0]));
    p3 = 7230607;
    all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
    // ------------------
  }

  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  }
  else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// PROBLEM STATEMENT
// There are N boxes numbered from 0 to N-1, inclusive. For each i, box i contains red[i] red balls, green[i] green balls, and blue[i] blue balls.
//
//
// Fox Ciel wants to separate the balls by colors. In each operation, she can pick a single ball from some box and put it into another box. She considers the balls to be separated if no box contains balls of more than one color.
//
//
// Return the minimal number of operations required to separate the balls. If this is impossible, return -1.
//
//
// DEFINITION
// Class:BallsSeparating
// Method:minOperations
// Parameters:vector <int>, vector <int>, vector <int>
// Returns:int
// Method signature:int minOperations(vector <int> red, vector <int> green, vector <int> blue)
//
//
// CONSTRAINTS
// -red, green and blue will each contain between 1 and 50 elements, inclusive.
// -red, green and blue will contain the same number of elements.
// -Each element of red, green and blue will be between 1 and 1,000,000, inclusive.
//
//
// EXAMPLES
//
// 0)
// {1, 1, 1}
// {1, 1, 1}
// {1, 1, 1}
//
// Returns: 6
//
// One way to separate the balls in six operations is as follows:
//
// Move a red ball from box 1 to box 0.
// Move a red ball from box 2 to box 0.
// Move a green ball from box 0 to box 1.
// Move a green ball from box 2 to box 1.
// Move a blue ball from box 0 to box 2.
// Move a blue ball from box 1 to box 2.
//
// The pictures on the left and on the right show the initial and the final states of the balls, respectively.
//
//
//
// ï¿½
//
//
// 1)
// {5}
// {6}
// {8}
//
// Returns: -1
//
// It is impossible to separate the balls.
//
// 2)
// {4, 6, 5, 7}
// {7, 4, 6, 3}
// {6, 5, 3, 8}
//
// Returns: 37
//
//
//
// 3)
// {7, 12, 9, 9, 7}
// {7, 10, 8, 8, 9}
// {8, 9, 5, 6, 13}
//
// Returns: 77
//
//
//
// 4)
// {842398, 491273, 958925, 849859, 771363, 67803, 184892, 391907, 256150, 75799}
// {268944, 342402, 894352, 228640, 903885, 908656, 414271, 292588, 852057, 889141}
// {662939, 340220, 600081, 390298, 376707, 372199, 435097, 40266, 145590, 505103}
//
// Returns: 7230607
//
//
//
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
