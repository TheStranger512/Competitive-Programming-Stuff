/*
 * Solved
 * SRM 524 Div1 Easy
 * Author: Andy Y.F. Huang
 */
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

using namespace std;
template <class A> inline void pln(A a){cout << a << endl;}
template <class it> inline void plnarr(it begin, it end)
{cout<<'[';if(begin<end){while (true){cout<<(*begin);if(++begin==end)break;else cout<<',';}}cout<<']'<<endl;}
typedef long long llong;

class MagicDiamonds {
public:
	llong minimalTransfer(llong n);
};

llong MagicDiamonds::minimalTransfer(llong n) {
	if (n == 3) return 3;
	if (n == 1) return 1;
	for (llong i = 2; i*i<=n;i++) {
		if (n % i ==0) return 1;
	}
	return 2;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, llong p0, bool hasAnswer, llong p1) {
	cout << "Test " << testNum << ": [" << p0;
	cout << "]" << endl;
	MagicDiamonds *obj;
	llong answer;
	obj = new MagicDiamonds();
	clock_t startTime = clock();
	answer = obj->minimalTransfer(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	llong p0;
	llong p1;
	
	{
	// ----- test 0 -----
	p0 = 2ll;
	p1 = 2ll;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 4294967297ll;
	p1 = 1ll;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 2147483647ll;
	p1 = 2ll;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 1ll;
	p1 = 1ll;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You found n Magic Diamonds in the mountain. You are now thinking about transfering them to your home.
// The only way you can transfer Magic Diamonds is to use Transfer Magic one or more times.
// 
// 
// The Magic Diamonds are very strange.
// For any positive integer x you can use Transfer Magic to transfer x Magic Diamonds at once. However, if x is a prime number, the Magic Diamonds will disappear instead of getting transferred. You are not allowed to lose any of the Magic Diamonds, therefore you may never use Transfer Magic on a prime number of Magic Diamonds. Your task is to transfer all Magic Diamonds using Transfer Magic as few times as possible.
// 
// 
// 
// You are given a long long n. Return the minimal number of Transfer Magic usages you need to transfer n Magic Diamonds.
// 
// DEFINITION
// Class:MagicDiamonds
// Method:minimalTransfer
// Parameters:long long
// Returns:long long
// Method signature:long long minimalTransfer(long long n)
// 
// 
// NOTES
// -A positive integer x is a prime number if and only if it has exactly 2 divisors: 1 and x. Note that 1 is not a prime number.
// -Your task can always be accomplished. For example, you can use Transfer Magic n times and transfer 1 Magic Diamond each time.
// 
// 
// CONSTRAINTS
// -n will be between 1 and 1,000,000,000,000 (10^12), inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 2
// 
// Returns: 2
// 
// We have to use Transfer Magic twice, each time we transfer 1 Magic Diamond.
// 
// 1)
// 4294967297
// 
// Returns: 1
// 
// We just need to use Transfer Magic once, because 4294967297 is not a prime. We have 4294967297 = 641 * 6700417.
// 
// 2)
// 2147483647
// 
// Returns: 2
// 
// This time n is a prime, so we have to use Transfer Magic at least twice. We have 2147483647 = 2147400000 + 83647 (83647 = 233 * 359, which is not a prime), thus the answer is 2.
// 
// 3)
// 1
// 
// Returns: 1
// 
// 
// 
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
